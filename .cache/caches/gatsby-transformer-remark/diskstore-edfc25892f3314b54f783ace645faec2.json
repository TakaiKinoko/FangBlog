{
  "expireTime": 9007200830476958000,
  "key": "transformer-remark-markdown-html-77a613bcd9be29ad1d2d40cc9b0a9ccc-gatsby-remark-imagesgatsby-remark-responsive-iframegatsby-remark-prismjsgatsby-remark-copy-linked-filesgatsby-remark-smartypantsgatsby-remark-reading-time-",
  "val": "<p>This is the third post in a series about what I learnt in my GPU class at NYU this past fall. Here I dive a bit deeper than the previous post into thread divergence.</p>\n<h2>Using Control Construct with Thread Divergence</h2>\n<p>A prevalent reason for using a control construct with thread divergence is <strong>handling boundary conditions</strong> when mapping threads to data. </p>\n<ul>\n<li>This is usually because the <em>total number of threads</em> needs to be a <em>multiple of the block size</em> whereas the size of the data can be an arbitrary number. </li>\n</ul>\n<h4>example with a vector addition kernel</h4>\n<p>In the vector addition kernel below, there’s an if <code class=\"language-text\">(i&lt;n)</code> statement in addVecKernel.\nThis is because not all vector lengths can be expressed as multiples of the block size.</p>\n<div class=\"gatsby-highlight\" data-language=\"c\"><pre class=\"language-c\"><code class=\"language-c\"><span class=\"token comment\">// Compute vector sum C = A+B</span>\n<span class=\"token comment\">// Each thread performs one element-wise addition</span>\n__global__ <span class=\"token function\">vecAddKernel</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">{</span>\n     <span class=\"token keyword\">int</span> i <span class=\"token operator\">=</span> blockDim<span class=\"token punctuation\">.</span>x <span class=\"token operator\">*</span> blockIdx<span class=\"token punctuation\">.</span>x <span class=\"token operator\">+</span> threadIdx<span class=\"token punctuation\">.</span>x<span class=\"token punctuation\">;</span>\n     <span class=\"token keyword\">if</span><span class=\"token punctuation\">(</span>i <span class=\"token operator\">&lt;</span> n<span class=\"token punctuation\">)</span> C<span class=\"token punctuation\">[</span>I<span class=\"token punctuation\">]</span> <span class=\"token operator\">=</span> A<span class=\"token punctuation\">[</span>I<span class=\"token punctuation\">]</span> <span class=\"token operator\">+</span> B<span class=\"token punctuation\">[</span><span class=\"token number\">1</span><span class=\"token punctuation\">]</span><span class=\"token punctuation\">;</span>\n<span class=\"token punctuation\">}</span></code></pre></div>\n<p>For example, assume that:</p>\n<ul>\n<li>vector length is 1003</li>\n<li>block size is 64\n</li>\n</ul>\n<p>To process all the 1003 vector elements:</p>\n<ul>\n<li>16 thread blocks are launched</li>\n<li>the total number of threads in these blocks would be 1024 threads </li>\n<li>the last 21 threads in thread block 15 need to be disabled</li>\n<li>these 16 blocks are partitioned into 32 warps, <strong>only the last warp will have control divergence</strong>.</li>\n</ul>\n<h2></h2>\n<p>Note that the performance impact of control divergence decreases with the size of the vectors being processed. For a vector length of 100, one of the four warps will have control divergence, which can have significant impact on performance. For a vector size of 1000, only one out of the 32 warps will have control divergence. That is, control divergence will affect only about 3% of the execution time. Even if it doubles the execution time of the warp, the net impact to the total execution time will be about 3%. Obviously, if the vector length is 10,000 or more, only one of the 313 warps will have control divergence. The impact of control divergence will be much less than 1%!</p>\n<p>For two-dimensional data, such as the color-to-greyscale conversion example, if-statements are also used to handle the boundary conditions for threads that operate at the edge of the data. In Fig. 3.2, to process the 76×62 picture, we used 20 =5*4 two-dimensional blocks that consist of 16×16 threads each. Each block will be partitioned into 8 warps, each one consists of two rows of a block. There are a total 160 warps (8 warps per block) involved.</p>\n<p>To analyze the impact of control divergence, refer to Fig. 3.5. None of the warps in the 12 blocks in region 1 will have control divergence. There are 12*8 =96 warps in region 1. For region 2, all the 24 warps will have control divergence. For region 3, note that all the bottom warps are mapped to data that are completely outside the picture. As a result, none of them will pass the if-condition. The reader should verify that these warps would have had control divergence if the picture had an odd number of pixels in the vertical dimension. Since they all follow the same control flow path, none of these 32 warps will have control divergence! In region 4, the first seven warps will have control divergence but the last warp will not. All in all, 31 out of the 160 warps will have control divergence.</p>"
}
