{
  "expireTime": 9007200830738406000,
  "key": "transformer-remark-markdown-html-ast-64fb2bfba53ddb6864adb133f3771916-gatsby-remark-imagesgatsby-remark-responsive-iframegatsby-remark-prismjsgatsby-remark-copy-linked-filesgatsby-remark-smartypantsgatsby-remark-reading-time-",
  "val": {
    "type": "root",
    "children": [
      {
        "type": "element",
        "tagName": "p",
        "properties": {},
        "children": [
          {
            "type": "text",
            "value": "There’s an intrinsic tradeoff in the use of device memories in CUDA: the ",
            "position": {
              "start": { "line": 2, "column": 1, "offset": 1 },
              "end": { "line": 2, "column": 74, "offset": 74 }
            }
          },
          {
            "type": "element",
            "tagName": "strong",
            "properties": {},
            "children": [
              {
                "type": "text",
                "value": "global memory",
                "position": {
                  "start": { "line": 2, "column": 76, "offset": 76 },
                  "end": { "line": 2, "column": 89, "offset": 89 }
                }
              }
            ],
            "position": {
              "start": { "line": 2, "column": 74, "offset": 74 },
              "end": { "line": 2, "column": 91, "offset": 91 }
            }
          },
          {
            "type": "text",
            "value": " is large but slow, whereas the ",
            "position": {
              "start": { "line": 2, "column": 91, "offset": 91 },
              "end": { "line": 2, "column": 123, "offset": 123 }
            }
          },
          {
            "type": "element",
            "tagName": "strong",
            "properties": {},
            "children": [
              {
                "type": "text",
                "value": "shared memory",
                "position": {
                  "start": { "line": 2, "column": 125, "offset": 125 },
                  "end": { "line": 2, "column": 138, "offset": 138 }
                }
              }
            ],
            "position": {
              "start": { "line": 2, "column": 123, "offset": 123 },
              "end": { "line": 2, "column": 140, "offset": 140 }
            }
          },
          {
            "type": "text",
            "value": " is small but fast.",
            "position": {
              "start": { "line": 2, "column": 140, "offset": 140 },
              "end": { "line": 2, "column": 159, "offset": 159 }
            }
          }
        ],
        "position": {
          "start": { "line": 2, "column": 1, "offset": 1 },
          "end": { "line": 2, "column": 159, "offset": 159 }
        }
      },
      { "type": "text", "value": "\n" },
      {
        "type": "element",
        "tagName": "p",
        "properties": {},
        "children": [
          {
            "type": "text",
            "value": "To recap on the memory hierarchy:\nA common strategy is to partition the data into subsets called tiles so that each tile fits into the shared memory. The term “tile” draws on the analogy that a large wall (i.e., the global memory data) can be covered by tiles (i.e., subsets that each can fit into the shared memory). An important criterion is that kernel computation on these tiles can be performed independently of each other. Note that not all data structures can be partitioned into tiles given an arbitrary kernel function.",
            "position": {
              "start": { "line": 4, "column": 1, "offset": 161 },
              "end": { "line": 5, "column": 495, "offset": 690 }
            }
          }
        ],
        "position": {
          "start": { "line": 4, "column": 1, "offset": 161 },
          "end": { "line": 5, "column": 495, "offset": 690 }
        }
      }
    ],
    "position": {
      "start": { "line": 1, "column": 1, "offset": 0 },
      "end": { "line": 5, "column": 495, "offset": 690 }
    }
  }
}
