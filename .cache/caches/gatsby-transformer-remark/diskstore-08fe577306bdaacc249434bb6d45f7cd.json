{
  "expireTime": 9007200830510720000,
  "key": "transformer-remark-markdown-html-07c046a1645ce628aea26f41f5b3cd18-gatsby-remark-imagesgatsby-remark-responsive-iframegatsby-remark-prismjsgatsby-remark-copy-linked-filesgatsby-remark-smartypantsgatsby-remark-reading-time-",
  "val": "<h2>Notation</h2>\n<ul>\n<li>Matrix <code class=\"language-text\">M</code></li>\n<li>Matrix <code class=\"language-text\">N</code></li>\n<li>Output Matrix <code class=\"language-text\">P</code></li>\n<li>row counter: <code class=\"language-text\">i</code></li>\n<li>column counter: <code class=\"language-text\">j</code></li>\n<li><code class=\"language-text\">P(Row, Col)</code> is the element at <code class=\"language-text\">Row-th</code> position in the vertical direction and <code class=\"language-text\">Col-th</code> position in the horizontal direction</li>\n</ul>\n<p>As shown in the picture below, <code class=\"language-text\">P(Row,Col)</code> (the small square in P) is the inner product of:</p>\n<ul>\n<li>the <code class=\"language-text\">Row-th</code> row of M</li>\n<li>the <code class=\"language-text\">Col-th</code> column of N</li>\n</ul>\n<p><img src=\"./matmult.jpg\" alt=\"matmul\"></p>\n<h2>Indexing</h2>\n<p>The row index for the P element is:</p>\n<p><code class=\"language-text\">Row = blockIdx.y * blockDim.y + threadIdx.y</code></p>\n<p>The column index for the P element is:</p>\n<p><code class=\"language-text\">Col = blockIdx.x * blockDim.x + threadIdx.x</code></p>\n<p>With this one-to-one mapping, the <code class=\"language-text\">Row</code> and <code class=\"language-text\">Col</code> thread indexes are also the row and column indexes for output array</p>\n<h2>Simple Kernel Using One Thread</h2>\n<p>Note that the <code class=\"language-text\">Width</code> used below is the <code class=\"language-text\">Width</code> in the picture above.</p>\n<div class=\"gatsby-highlight\" data-language=\"c\"><pre class=\"language-c\"><code class=\"language-c\">__global__ <span class=\"token keyword\">void</span> MatrixMulKernel <span class=\"token punctuation\">(</span><span class=\"token keyword\">float</span><span class=\"token operator\">*</span> M<span class=\"token punctuation\">,</span> <span class=\"token keyword\">float</span><span class=\"token operator\">*</span> N<span class=\"token punctuation\">,</span> <span class=\"token keyword\">float</span><span class=\"token operator\">*</span> P<span class=\"token punctuation\">,</span> <span class=\"token keyword\">int</span> Width<span class=\"token punctuation\">)</span><span class=\"token punctuation\">{</span>\n    <span class=\"token comment\">// calculate the row index of the P element and M</span>\n    <span class=\"token keyword\">int</span> Row <span class=\"token operator\">=</span> blockIdx<span class=\"token punctuation\">.</span>y <span class=\"token operator\">*</span> blockDim<span class=\"token punctuation\">.</span>y <span class=\"token operator\">+</span> threadIdx<span class=\"token punctuation\">.</span>y<span class=\"token punctuation\">;</span>\n    <span class=\"token comment\">// calculate the col index of the P element and N</span>\n    <span class=\"token keyword\">int</span> Col <span class=\"token operator\">=</span> blockIdx<span class=\"token punctuation\">.</span>x <span class=\"token operator\">*</span> blockDim<span class=\"token punctuation\">.</span>x <span class=\"token operator\">+</span> threadIdx<span class=\"token punctuation\">.</span>x<span class=\"token punctuation\">;</span>\n\n    <span class=\"token keyword\">if</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">(</span>Row <span class=\"token operator\">&lt;</span> Width<span class=\"token punctuation\">)</span> <span class=\"token operator\">&amp;&amp;</span> <span class=\"token punctuation\">(</span>Col <span class=\"token operator\">&lt;</span> Width<span class=\"token operator\">></span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">{</span>\n        <span class=\"token keyword\">float</span> Pvalue <span class=\"token operator\">=</span> <span class=\"token number\">0</span><span class=\"token punctuation\">;</span>\n        <span class=\"token comment\">//each thread computes one element of the block sub-matrix</span>\n        <span class=\"token keyword\">for</span><span class=\"token punctuation\">(</span><span class=\"token keyword\">int</span> k <span class=\"token operator\">=</span> <span class=\"token number\">0</span><span class=\"token punctuation\">;</span> k <span class=\"token operator\">&lt;</span> Width<span class=\"token punctuation\">;</span> k<span class=\"token operator\">++</span><span class=\"token punctuation\">)</span> <span class=\"token punctuation\">{</span>\n            Pvalue <span class=\"token operator\">+</span><span class=\"token operator\">=</span> M<span class=\"token punctuation\">[</span>Row<span class=\"token operator\">*</span>Width <span class=\"token operator\">+</span> k<span class=\"token punctuation\">]</span> <span class=\"token operator\">*</span> N<span class=\"token punctuation\">[</span>k<span class=\"token operator\">*</span>Width <span class=\"token operator\">+</span> Col<span class=\"token punctuation\">]</span><span class=\"token punctuation\">;</span>\n        <span class=\"token punctuation\">}</span>\n        P<span class=\"token punctuation\">[</span>Row <span class=\"token operator\">*</span> Width <span class=\"token operator\">+</span> Col<span class=\"token punctuation\">]</span> <span class=\"token operator\">=</span> Pvalue<span class=\"token punctuation\">;</span>\n    <span class=\"token punctuation\">}</span>\n<span class=\"token punctuation\">}</span></code></pre></div>\n<h4>memory access of the for loop</h4>\n<p>In every iteration of the loop, <strong>two global memory accesses</strong> are performed for one floating-point multiplication and one floating-point addition.</p>\n<h5>memory accesses</h5>\n<ul>\n<li>One global memory access fetches an M element</li>\n<li>the other fetches an N element</li>\n</ul>\n<h5>computation performed</h5>\n<ul>\n<li>One floating-point operation multiplies the M and N elements fetched</li>\n<li>the other accumulates the product into Pvalue</li>\n</ul>\n<h5>compute-to-global-memory-access ratio</h5>\n<p>The <strong>compute-to-global-memory-access ratio</strong> of the loop is 1.0.</p>\n<p>This ratio will likely result in less than 2% utilization of the peak execution speed of the modern GPUs.</p>\n<p>We need to increase the ratio by at least an order of magnitude for the computation throughput of modern devices to achieve good utilization.</p>\n<h2>Execution of the Matrix Multiplication Kernel Within A Block</h2>\n<h4>setting</h4>\n<ul>\n<li>\n<p>size of <code class=\"language-text\">P</code> is 4×4</p>\n</li>\n<li>\n<p><code class=\"language-text\">BLOCK_WIDTH = 2</code></p>\n</li>\n</ul>\n<h4>map threads to P</h4>\n<p>With:</p>\n<ul>\n<li>blocks that are 2×2 arrays of threads</li>\n<li>each thread calculating one P element</li>\n</ul>\n<p><img src=\"./execution.jpg\" alt=\"execution\"></p>\n<p>The P matrix is now divided into four tiles, and each block calculates one tile.</p>\n<ul>\n<li>In the example, <code class=\"language-text\">thread(0,0)</code> of <code class=\"language-text\">block(0,0)</code> calculates <code class=\"language-text\">P(0,0)</code></li>\n<li><code class=\"language-text\">thread(0,0)</code> of <code class=\"language-text\">block(1,0)</code> calculates <code class=\"language-text\">P(2,0)</code></li>\n</ul>\n<h4>actions of one thread block</h4>\n<p>The picture below illustrates the multiplication operations in each thread block.</p>\n<p>Threads in block (0,0) produce four dot products.</p>\n<p><img src=\"./block.jpg\" alt=\"execution of one thread block\"></p>\n<h4>the execution of the for-loop</h4>\n<p>Use <code class=\"language-text\">thread(0,0)</code> in <code class=\"language-text\">block(0,0)</code> as an example.</p>\n<ul>\n<li>\n<p>During the 0th iteration (k=0):</p>\n<ul>\n<li><code class=\"language-text\">Row * Width + k = 0*4+0 = 0</code></li>\n<li><code class=\"language-text\">k * Width + Col= 0*4+0 = 0</code></li>\n<li>Therefore, we are accessing <code class=\"language-text\">M[0]</code> and <code class=\"language-text\">N[0]</code>, which are the 1D equivalent of <code class=\"language-text\">M(0,0)</code> and <code class=\"language-text\">N(0,0)</code></li>\n</ul>\n</li>\n<li>\n<p>During the 1st iteration (k=1):</p>\n<ul>\n<li><code class=\"language-text\">Row * Width + k = 0*4+1 = 1</code></li>\n<li><code class=\"language-text\">k * Width + Col = 1*4+0 = 4</code></li>\n<li>We are accessing <code class=\"language-text\">M[1]</code> and <code class=\"language-text\">N[4]</code>, which are the 1D equivalent of <code class=\"language-text\">M(0,1)</code> and <code class=\"language-text\">N(1,0)</code></li>\n</ul>\n</li>\n</ul>\n<h2>Tiled Kernel</h2>\n<p>To see how to use tiling (corner turning) technique to overcome the fact that row-wise access of matrix M cannot be coalesced, see <em>Corner Turning</em> section in <a href=\"./cuda5-coalesce\">The CUDA Parallel Programming Model - 5.Memory Coalescing</a>.</p>"
}
