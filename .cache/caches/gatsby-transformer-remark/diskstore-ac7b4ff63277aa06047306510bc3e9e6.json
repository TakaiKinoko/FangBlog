{
  "expireTime": 9007200830672717000,
  "key": "transformer-remark-markdown-html-29e93619bdfe6e6b23fb6a48d023ba6f-gatsby-remark-imagesgatsby-remark-responsive-iframegatsby-remark-prismjsgatsby-remark-copy-linked-filesgatsby-remark-smartypantsgatsby-remark-reading-time-",
  "val": "<p>This is the fourth post in a series about what I learnt in my GPU class at NYU this past fall. Here I collected several examples that showcase how the CUDA <code class=\"language-text\">__syncthreads()</code> command should (or should not) be used.</p>\n<h2>Some Notes On Synchronization</h2>\n<h3>barrier synchronization</h3>\n<p>To coordinate the execution of multiple threads, CUDA allows threads in the same block to coordinate their activities by using a barrier synchronization function <code class=\"language-text\">__syncthreads()</code>. This process ensures that all threads in a block have completed a phase of their execution of the kernel before any of them can proceed to the next phase.</p>\n<ul>\n<li><code class=\"language-text\">__syncthreads()</code> is called by a kernel function</li>\n<li>The thread that makes the call will be held at the calling location until <strong>every thread in the block</strong> reaches the location</li>\n<li>Threads in different blocks <strong>cannot</strong> synchronize! CUDA runtime system can execute blocks in any order.</li>\n</ul>\n<p>Barrier synchronization is a simple and popular method for coordinating parallel activities. </p>\n<h3>resources assignment and temporal proximity of threads</h3>\n<p>CUDA also assigns execution resources to all threads in a block as a unit. A block can begin execution only when the runtime system has secured all resources needed for all threads in the block to complete execution.  All threads in the same block are assigned the same resources.</p>\n<p>This condition ensures the temporal proximity of all threads in a block and prevents excessive or indefinite waiting time during barrier synchronization</p>\n<h3>transparent scalability</h3>\n<p>The above leads to an important tradeoff in the design of CUDA barrier synchronization. By <strong>not allowing</strong> threads in <strong>different blocks</strong> to perform barrier synchronization with each other, the CUDA runtime system can <strong>execute blocks in any order</strong> relative to each other because none of them need to wait for each other. This flexibility enables scalable implementations shown in the figure below.</p>\n<p><figure class=\"gatsby-resp-image-figure\" style=\"\">\n    <span\n      class=\"gatsby-resp-image-wrapper\"\n      style=\"position: relative; display: block; margin-left: auto; margin-right: auto;  max-width: 590px;\"\n    >\n      <a\n    class=\"gatsby-resp-image-link\"\n    href=\"/static/ffbcd81316a8491ec406d69178383f03/d7a30/trans_scalability.png\"\n    style=\"display: block\"\n    target=\"_blank\"\n    rel=\"noopener\"\n  >\n    <span\n    class=\"gatsby-resp-image-background-image\"\n    style=\"padding-bottom: 39.54887218045113%; position: relative; bottom: 0; left: 0; background-image: url('data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAABQAAAAICAYAAAD5nd/tAAAACXBIWXMAABYlAAAWJQFJUiTwAAABf0lEQVQoz4VRS6tBURQ+/05nZOAnmBgayERJEhmRiVIHRZGQXyCFiVOc46Q8Sh7JOQjl/fxua+nerlu6q769dt/a+1sv4fl84q8R94n/zwQ6+v0+2u02JpMJptMpB263G/L5PFKpFAqFAjabDfPb7Raz2QyHw+EN+/0el8vlJUgi3W4Xg8EAo9EIx+MRw+EQNpsNZrMZFosFjUaDeUoqyzI6nQ5D0zT2iqJgtVpBoErK5TJisRhXUywW0ev1sFgsYLVaYTKZIIoid0FizWYTlUoF9Xod1WqV77VajTUMw4BwvV6RTqfhcDjgdrshSRK3dj6fEQ6H4fF4GOPxGKfTiUXsdjsCgQC8Xi9cLhd8Ph+cTidUVX0J0qzoUzAYRCaT+bgAStJqtRAKhZBMJhGPxxGNRpFIJBCJRHhkAg2yVCpxRnqYy+Ww2+2g6zrPZLlccvvr9Rrz+Zx5utNyyNMbqvxny7ShbDbL7fr9fm6f7H6/4/F4vIGqJk+x3/iOEb4Ah/0rtbCGiQMAAAAASUVORK5CYII='); background-size: cover; display: block;\"\n  ></span>\n  <img\n        class=\"gatsby-resp-image-image\"\n        alt=\"transparent scalability\"\n        title=\"transparent scalability\"\n        src=\"/static/ffbcd81316a8491ec406d69178383f03/799d3/trans_scalability.png\"\n        srcset=\"/static/ffbcd81316a8491ec406d69178383f03/00d96/trans_scalability.png 148w,\n/static/ffbcd81316a8491ec406d69178383f03/0b23c/trans_scalability.png 295w,\n/static/ffbcd81316a8491ec406d69178383f03/799d3/trans_scalability.png 590w,\n/static/ffbcd81316a8491ec406d69178383f03/2a3d6/trans_scalability.png 885w,\n/static/ffbcd81316a8491ec406d69178383f03/ae92f/trans_scalability.png 1180w,\n/static/ffbcd81316a8491ec406d69178383f03/d7a30/trans_scalability.png 1330w\"\n        sizes=\"(max-width: 590px) 100vw, 590px\"\n        loading=\"lazy\"\n      />\n  </a>\n    </span>\n    <figcaption class=\"gatsby-resp-image-figcaption\">transparent scalability</figcaption>\n  </figure></p>\n<p>In a low-cost systenm with only a few execution resources, one can execute a small number of blocks simultaneously (left-hand-side).\nIn a high-end implementaion, one can execute a large number of blocks simultaneously (right-hand-side).</p>\n<h2>Example 1</h2>\n<div class=\"gatsby-highlight\" data-language=\"c\"><pre class=\"language-c\"><code class=\"language-c\">__shared__ <span class=\"token keyword\">float</span> partialSum<span class=\"token punctuation\">[</span>SIZE<span class=\"token punctuation\">]</span><span class=\"token punctuation\">;</span>\npartialSum<span class=\"token punctuation\">[</span>threadIdx<span class=\"token punctuation\">.</span>x<span class=\"token punctuation\">]</span> <span class=\"token operator\">=</span> X<span class=\"token punctuation\">[</span>blockIdx<span class=\"token punctuation\">.</span>x <span class=\"token operator\">*</span> blockDim<span class=\"token punctuation\">.</span>x <span class=\"token operator\">+</span> threadIdx<span class=\"token punctuation\">.</span>x<span class=\"token punctuation\">]</span><span class=\"token punctuation\">;</span>\n<span class=\"token keyword\">unsigned</span> <span class=\"token keyword\">int</span> t <span class=\"token operator\">=</span> threadIdx<span class=\"token punctuation\">.</span>x<span class=\"token punctuation\">;</span>\n<span class=\"token keyword\">for</span><span class=\"token punctuation\">(</span><span class=\"token keyword\">unsigned</span> <span class=\"token keyword\">int</span> stride <span class=\"token operator\">=</span> <span class=\"token number\">1</span><span class=\"token punctuation\">;</span> stride <span class=\"token operator\">&lt;</span> blockDim<span class=\"token punctuation\">.</span>x<span class=\"token punctuation\">;</span> stride <span class=\"token operator\">*=</span> <span class=\"token number\">2</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">{</span>\n     <span class=\"token function\">__syncthreads</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n     <span class=\"token keyword\">if</span><span class=\"token punctuation\">(</span>t <span class=\"token operator\">%</span> <span class=\"token punctuation\">(</span><span class=\"token number\">2</span><span class=\"token operator\">*</span>stride<span class=\"token punctuation\">)</span> <span class=\"token operator\">==</span> <span class=\"token number\">0</span><span class=\"token punctuation\">)</span>\n          partialSum<span class=\"token punctuation\">[</span>t<span class=\"token punctuation\">]</span> <span class=\"token operator\">+=</span> partialSum<span class=\"token punctuation\">[</span>t<span class=\"token operator\">+</span>stride<span class=\"token punctuation\">]</span><span class=\"token punctuation\">;</span>\n<span class=\"token punctuation\">}</span></code></pre></div>\n<p>The <code class=\"language-text\">__syncthreads()</code> statement in the for-loop ensures that all partial sums for the previous iteration have been generated and before any one of the threads is allowed to begin the current iteration. This way, all threads that enter the second iteration will be using the values produced in the first iteration.</p>\n<h2>Example 2</h2>\n<p>How to sync threads when there’s <strong>thread divergence</strong>?</p>\n<p><code class=\"language-text\">__syncthreads()</code> is a barrier statement in CUDA, where if it’s present, <strong>must be executed by all threads in a block</strong>. </p>\n<ul>\n<li>When a <code class=\"language-text\">__syncthreads()</code> statement is placed in an if-statement, either all or none of the threads in a block execute the path that includes the <code class=\"language-text\">__syncthreads()</code>.</li>\n<li>For an <code class=\"language-text\">if-then-else</code> statement, if each path has a <code class=\"language-text\">__syncthreads()</code> statement, either all threads in a block execute the <code class=\"language-text\">then-path</code> or all execute the <code class=\"language-text\">else-path</code>. Because the two <code class=\"language-text\">__syncthreads()</code> are different barrier synchronization points. If a thread in a block executes the <code class=\"language-text\">then-path</code> and another executes the <code class=\"language-text\">else-path</code>, they would be waiting at different barrier synchronization points and end up waiting for each other forever.</li>\n</ul>\n<p>The code below is problematic because of exactly the above reason. Some threads will be stuck in the <code class=\"language-text\">if</code> branch whereas others in the <code class=\"language-text\">else</code> branch — deadlock!</p>\n<div class=\"gatsby-highlight\" data-language=\"c\"><pre class=\"language-c\"><code class=\"language-c\"><span class=\"token keyword\">if</span><span class=\"token punctuation\">{</span>\n     <span class=\"token punctuation\">.</span><span class=\"token punctuation\">.</span><span class=\"token punctuation\">.</span>\n     <span class=\"token function\">__syncthreads</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n<span class=\"token punctuation\">}</span><span class=\"token keyword\">else</span><span class=\"token punctuation\">{</span>\n     <span class=\"token punctuation\">.</span><span class=\"token punctuation\">.</span><span class=\"token punctuation\">.</span>\n     <span class=\"token function\">__syncthreads</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n<span class=\"token punctuation\">}</span></code></pre></div>\n<p>To fix it is simple:</p>\n<div class=\"gatsby-highlight\" data-language=\"c\"><pre class=\"language-c\"><code class=\"language-c\"><span class=\"token keyword\">if</span><span class=\"token punctuation\">{</span>\n     <span class=\"token punctuation\">.</span><span class=\"token punctuation\">.</span><span class=\"token punctuation\">.</span>\n<span class=\"token punctuation\">}</span><span class=\"token keyword\">else</span><span class=\"token punctuation\">{</span>\n     <span class=\"token punctuation\">.</span><span class=\"token punctuation\">.</span><span class=\"token punctuation\">.</span>\n<span class=\"token punctuation\">}</span>\n<span class=\"token function\">__syncthreads</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span></code></pre></div>"
}
